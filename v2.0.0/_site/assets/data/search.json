[
  
  {
    "title"    : "(Google ML Bootcamp LATAM) Notes on DLS Coursera",
    "category" : "coding, ML",
    "url"      : "/coding/ml/2022/07/06/DLS-Notes/",
    "date"     : "July 6, 2022",
    "excerpt"  : "Course 1: NNs and DL\n\nWeek 1: Introduction to DL.\nGeoffrey Hinton proved in the 90s that ReLU is a good approximation for a logistic regression. That’s  why ReLU works fine in DNNs.\n\nWeek 2: NNs Basics\n\nPython Broadcasting is more powerful than ex...",
    "content"  : "Course 1: NNs and DL\n\nWeek 1: Introduction to DL.\nGeoffrey Hinton proved in the 90s that ReLU is a good approximation for a logistic regression. That’s  why ReLU works fine in DNNs.\n\nWeek 2: NNs Basics\n\nPython Broadcasting is more powerful than expected haha.\n\nCourse 2: Improving DNNs: Hyperparameter Tuning, Regularization and Optimization\n\nCourse 3: Structuring Machine Learning Projects\n\nCourse 4: CNNs\n\n"
} ,
  
  {
    "title"    : "(c++) 387 - First Unique Character in a String",
    "category" : "Leetcode, cpp",
    "url"      : "/leetcode/cpp/2022/06/11/387-easy-cpp-hstbl/",
    "date"     : "June 11, 2022",
    "excerpt"  : "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n\nBrute force\n\nInput: s = “leetcode”\n\n\n  I take a look at l, I check if does repeat I go next. In this case it doesnt so it is the...",
    "content"  : "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n\nBrute force\n\nInput: s = “leetcode”\n\n\n  I take a look at l, I check if does repeat I go next. In this case it doesnt so it is the solution. We only care about the first one which doesnt repeat.\n\n\nInput: s = “aaccaddleetcode”\n\n\n  \n    I take a look at a, I check if does repeat I go next. In this case it repeat thefore I skip. Next value is also a, as before, so we should delete all the instances of a to be sure.\n  \n  Now the input is s = “ccddleetcode”, we repeat the previous step\n  Now the input is s = “ddleetcode”, we repeat the previous step\n  Now the input is s = “leetcode”, we repeat the previous step\n  Now L doesnt repeat so it is the solution, its position in the original input was 4.\n\n\nThis is a $O(n^2)$\n\nBottlenecks\n\nSearching the repeated values makes the solution slow. Ideally we could make something like this\n\nx = (frecuency, first index)\t\n“a = (3,0)\n c = (3,2)\n d = (3,5)\n l = (1,6) - exit\n e\n t\n o\n d\n “\n\nMaybe I could a map with frequencies going once through the array, then I go again check the letters and its frequecy. This would be O(n)!\n\nhash map of input - O(n)\n“a = 3\n c = 3\n d = 3\n l = 1 \n e = 3\n t = 1\n o = 1”\n\ncheck the array again - O(n)\n\na - 3, skip,\na skip\nc skip\n…\nl return index\n\nCode\n\nint firstUniqChar(string s) {\n    unordered_map&amp;lt;char,int&amp;gt; hs{};\n    \n    for(const auto &amp;amp;i:s) hs[i]++; // O(n)\n    \n    for(int i=0; i &amp;lt; s.size(); i++)\n        if(hs.at(s[i])==1) return i; //n x O(1)\n    \n    return -1;\n}\n\nI need to go through the array at least   once to check if the first values repeats or not. The best possible runtime is a O(n) order\n\nCode 2.0 without maps\n\nWe fix an array with every letter, in theory the lookup time is faster in this case than a map.\n\nint firstUniqChar(string s) {\n    std::vector&amp;lt;int&amp;gt; v; hs(26);\n    \n    for(const auto &amp;amp;i:s) hs[i]++; // O(n)\n    \n    for(int i=0; i &amp;lt; s.size(); i++)\n        if(hs[s[i]]==1) return i; //n x O(1) - here is faster\n    \n    return -1;\n}\n\n"
} ,
  
  {
    "title"    : "Google SRE Book - Postmortem Culture [Extract]",
    "category" : "coding, essay",
    "url"      : "/coding/essay/2022/05/26/postmortem-report/",
    "date"     : "May 26, 2022",
    "excerpt"  : "Original from this source\n\nAs SREs, we work with large-scale, complex, distributed systems. We constantly enhance our services with new features and add new systems. Incidents and outages are inevitable given our scale and velocity of change. When...",
    "content"  : "Original from this source\n\nAs SREs, we work with large-scale, complex, distributed systems. We constantly enhance our services with new features and add new systems. Incidents and outages are inevitable given our scale and velocity of change. When an incident occurs, we fix the underlying issue, and services return to their normal operating conditions. Unless we have some formalized process of learning from these incidents in place, they may recur ad infinitum. Left unchecked, incidents can multiply in complexity or even cascade, overwhelming a system and its operators and ultimately impacting our users. Therefore, postmortems are an essential tool for SRE.\n\nA postmortem is a written record of an incident, its impact, the actions taken to mitigate or resolve it, the root cause(s), and the follow-up actions to prevent the incident from recurring. This chapter describes criteria for deciding when to conduct postmortems, some best practices around postmortems, and advice on how to cultivate a postmortem culture based on the experience we’ve gained over the years.\n\nWriting a postmortem also involves formal review and publication. In practice, teams share the first postmortem draft internally and solicit a group of senior engineers to assess the draft for completeness. Review criteria might include:\n\n\n  Was key incident data collected for posterity?\n  Are the impact assessments complete?\n  Was the root cause sufficiently deep?\n  Is the action plan appropriate and are resulting bug fixes at appropriate priority?\n  Did we share the outcome with relevant stakeholders?\n\n\nOnce the initial review is complete, the postmortem is shared more broadly, typically with the larger engineering team or on an internal mailing list. Our goal is to share postmortems to the widest possible audience that would benefit from the knowledge or lessons imparted. Google has stringent rules around access to any piece of information that might identify an end-user,80 and even internal documents like postmortems never include such information.\n"
} ,
  
  {
    "title"    : "C++ - Notes",
    "category" : "coding, c++, cpp",
    "url"      : "/coding/c++/cpp/2022/05/17/cpp-notes/",
    "date"     : "May 17, 2022",
    "excerpt"  : "Static Function/Variables in a class\n\nLong time ago, I found a really nice example to understand it and I’m writing this post to document it. It took me a long time to understand what a static member/function is, why and when I should use it.\n\nCre...",
    "content"  : "Static Function/Variables in a class\n\nLong time ago, I found a really nice example to understand it and I’m writing this post to document it. It took me a long time to understand what a static member/function is, why and when I should use it.\n\nCreating a toy class\n\nLet’s create small code where we will emulate a service with users. We want to know at any time how many users we have, how can we do that?\n\nCode for the user class:\n\nclass User{\n\n\tpublic:\n\t\tstd::string name;\n\t\tUser(){ // Constr\n\n\t\t};\n\t\t~User(){  //Destr\n\n\t\t};\n};\n\n\nCounting the users in the main function:\n\nint main(){\n\tint user_counter = 2 ;\n\tUser user1, user2;\n\n\tuser2.~User();\n\tuser_counter--;\n}\n\n\nThis is not a good solution, I would have to count every time I create/delete a new user by hand. Wouldn’t it be nice to make c++ count for us? This is why we want to use a single variable inside the class to count: This is a static variable.\n\nCreating the user class with a static counter\n\nclass User{\n\n\tstatic int user_counter;\n\tpublic:\n\t\tstd::string name;\n\n\t\tUser(){ // Constr\n\t\t\tuser_counter++;\n\t\t};\n\n\t\t~User(){  //Destr\n\t\t\tuser_counter--;\n\t\t};\n};\n\n\nNow, the user_counter value goes up/down when the constructor/destructor is called.\n\nint main(){\n\tUser user1, user2; //user_counter = 2 \n\tuser2.~User(); //user_counter = 1\n}\n\nHow do we access this static counter?: Static Functions\n\n“Normal” functions can’t access static variables, and it makes sense since these variables are global to every instance of the class, i.e. the number of users can’t be accessed easily as it’s shared by everyone.\n\nclass User{\n\n\tstatic int user_counter;\n\tpublic:\n\t\tstd::string name;\n\n\t\tstatic int get_user_count() {return user_counter;}\n\n\t\tUser(){ // Constr\n\t\t\tuser_counter++;\n\t\t};\n\n\t\t~User(){  //Destr\n\t\t\tuser_counter--;\n\t\t};\n};\n\n\nGreat, but  how do i initiate the user_counter variable? It’s a shared variable, so we can’t simply write static int user_counter = 0 inside the user class, so need to initiate outside of it!\n\n//Below the User class\nint User::user_counter = 0; \n\nint main(){\n\tstd::cout &amp;lt;&amp;lt; User::get_user_count() &amp;lt;&amp;lt; &quot;\\n&quot;;\n\tUser user1, user2; //user_counter = 2\n\n\tstd::cout &amp;lt;&amp;lt; User::get_user_count() &amp;lt;&amp;lt; &quot;\\n&quot;;\n\tuser2.~User(); //user_counter = 1\n\n\tstd::cout &amp;lt;&amp;lt; User::get_user_count() &amp;lt;&amp;lt; &quot;\\n&quot;;\t\n}\nOutput:\n0\n2\n1\n\n\nThe full working code:\n\n#include &amp;lt;iostream&amp;gt;\n\nclass User{\n\n\tstatic int user_counter;\n\tpublic:\n\t\tstd::string name;\n\n\t\tstatic int get_user_count() {return user_counter;}\n\n\t\tUser(){ // Constr\n\t\t\tuser_counter++;\n\t\t};\n\n\t\t~User(){  //Destr\n\t\t\tuser_counter--;\n\t\t};\n};\n\nint User::user_counter = 0; \n\nint main(){\n\tstd::cout &amp;lt;&amp;lt; User::get_user_count() &amp;lt;&amp;lt; &quot;\\n&quot;;\n\tUser user1, user2; //user_counter = 2\n\n\tstd::cout &amp;lt;&amp;lt; User::get_user_count() &amp;lt;&amp;lt; &quot;\\n&quot;;\n\tuser2.~User(); //user_counter = 1\n\n\tstd::cout &amp;lt;&amp;lt; User::get_user_count() &amp;lt;&amp;lt; &quot;\\n&quot;;\t\n}\n\n\nistringstream from sstream:\nThis helps to get word from a string separated by a space.\n\n...\nstd::string s = &quot;foo bar&quot;;\nstd::istringstream p_s(s);\n\nwhile(p_s) {\n\tp_s &amp;gt;&amp;gt; word; # get the word to the variable\n\tstd::cout&amp;lt;&amp;lt;word&amp;lt;&amp;lt;&quot;\\n&quot;;\n}\n...\n## Output ##\nfoo\nbar\n\n\n‘for_each’ superpower\nCpp reference\n\nLambda Expressions\n\nCpp reference\n\nunordered_set vs unordered_map\n\n\n  Set doesn’t need a value associated with the key, it’s a hash table with keys only\n  map is a hashtable, key and value pair.\n\n\npriority_queue\nImport using #include &amp;lt;queue&amp;gt;\nBy default:\n* template&amp;lt;\n    class T,\n    class Container = std::vector&amp;lt;T&amp;gt;,\n    class Compare = std::less&amp;lt;typename Container::value_type&amp;gt;\n&amp;gt; class priority_queue;\n//-- \nIn: 9 8 7 6 5 4 3 2 1 0 \n// using push!\nOut: 0 1 2 3 4 5 6 7 8 9 \n//--\n&amp;gt;\n\n"
} ,
  
  {
    "title"    : "Kadane&#39;s Algorithm &amp; LeetCode 53 Maximum Subarray",
    "category" : "coding, leetcode",
    "url"      : "/coding/leetcode/2022/05/11/Kadane/",
    "date"     : "May 11, 2022",
    "excerpt"  : "Kadane’s Algorithm is used to obtain the maximum subarray sum, as seen in the Leetcode 53. Maximum Subarray:\n\n\n  Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its su...",
    "content"  : "Kadane’s Algorithm is used to obtain the maximum subarray sum, as seen in the Leetcode 53. Maximum Subarray:\n\n\n  Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nA subarray is a contiguous part of an array.\nExample:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n\n\nBrute-force Approach\n\nLet’s take the example array:\n\n\n  [-2,1,-3,4,-1,2,1,-5,4]\n\n\nWe can solve the problem via brute-force but it goes as  $O(n²)$:\n\ndef maxSubArray(self, nums: List[int]) -&amp;gt; int:\n    best_sum = 0\n    current_sum = 0\n    \n    if len(nums)==1: return nums[0]\n        \n    for i,x in enumerate(nums):\n        current_sum=x\n        for  y in nums[i+1:]:\n            current_sum = current_sum + y\n            if current_sum&amp;gt;best_sum:\n                best_sum = current_sum\n\n    return best_sum    \n\n\nBasically, we calculate the following sums:\n\n\n  Fix the first value: -2\n1.1: -2+1 = -1 &amp;lt;- best_sum\n1.2: -2+1-3 = -4\n1.3: -2+1-3+4 = 0 &amp;lt;- best_sum\n1.4: -2+1-3+4-1 = -1\n….\nFix the fourth value: 4\n4.1: 4-1 = 3\n4.2: 4-1+2 = 5 &amp;lt;- best_sum\n4.3: 4-1+2+1 = 6 &amp;lt;-  best_sum, this won’t change\n….\n\n\nAbout Kadane:\n\nJoseph Kadane is a mathematician that provided this algorithm to solve the maximum subarray sum problem in $O(n)$ time complexity:\n\ndef maxSubarraySum(numbers: List[int]) -&amp;gt; int:\n    best_sum = nums[0]\n    current_sum = nums[0]\n\n    for x in nums[1:]:\n        current_sum = max(x, current_sum + x)\n        best_sum = max(best_sum, current_sum)\n    return best_sum\n\n\nEasy? Not easy for me. Let’s dig deeper into why it works.\n\nThe full sum array: Fix the first value: -2\n\n  $-2+1 = -1$ $\\rightarrow$ The second value $1$  alone has a higher sum than $-2+1$, therefore we ditch the $-2$ and we begin counting from $1$ for a new subarray, current_sum=1, best_sum=1\n  $1-3 = -2$ $\\rightarrow$ The third value is lower than the sum with the previous current_value ($-2&amp;gt;-3$), we continue a new subarray from last step. current_sum=-2, best_sum=1\n  $1-3+4 = 2$ $\\rightarrow$  The 4th value updates the current_value to $4$ and the best_value to $4$. This resets the subarray we were adding because $4$ alone has a higher sum than $1-3+4$.\n  $4-1 = 1$ $\\rightarrow$ current_sum=1, best_sum=4\n  $4-1 + 2 = 5$ $\\rightarrow$ current_sum=5, best_sum=5\n  $4-1 + 2 + 1= 6$ $\\rightarrow$ current_sum=6, best_sum=6, after this best_sum won’t be updated again.\n  $4-1 + 2 + 1 -1 = 5$ $\\rightarrow$ current_sum=5, best_sum=6\n  $4-1 + 2 + 1 -1 -5  = 0$ $\\rightarrow$ current_sum=0, best_sum=6\n  $4-1 + 2 + 1 -1 -5 + 4 = 4$ $\\rightarrow$ current_sum=4, best_sum=6\n\n\nIf we had an extra number (less than 2), we would have to update the subarray we were adding.\n\nIn general, in line 6 of the Kadane implementation we decide to switch to another subarray, this happens in step 2 and 3. Meanwhile, line 7 keeps the highest sum we got so far.\n"
} ,
  
  {
    "title"    : "SQL Notes",
    "category" : "coding, SQL",
    "url"      : "/coding/sql/2022/03/20/mysql-notes/",
    "date"     : "March 20, 2022",
    "excerpt"  : "JOIN vs. RIGHT JOIN vs. LEFT JOIN\n\nExtracted from this source\n\n\n  \n    (INNER) JOIN: Returns records that have matching values in both tables\n  \n  \n    LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the ri...",
    "content"  : "JOIN vs. RIGHT JOIN vs. LEFT JOIN\n\nExtracted from this source\n\n\n  \n    (INNER) JOIN: Returns records that have matching values in both tables\n  \n  \n    LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table\n  \n  \n    RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table\n  \n  \n    FULL (OUTER) JOIN: Returns all records when there is a match in either left or right table\n  \n\n\n\n\nHAVING vs. WHERE\n\nSELECT column_name(s)\nFROM table_name\nWHERE condition\nGROUP BY column_name(s)\nHAVING condition\nORDER BY column_name(s);\n\n\n  WHERE: Like if after SELECT xx FROM yy\n  HAVING: Only after every GROUP BY, it’s like WHERE but for aggregate functions.\n\n\n###\n\nIS vs =\n\nIS is for alphanumeric values and = is for numbers\n\ntest\n|name|value|\n|pepe| 11\t|\n|pepa| 5 |\n|peepo| 11| \n\n\nSELECT name FROM test\nWHERE name IS &quot;pep%&quot;\n\n&amp;gt;&amp;gt; pepe,pepa\n\nSELECT name FROM test\nWHERE value = 11\n\n&amp;gt;&amp;gt; pepe, peepo \n\n\n"
} ,
  
  {
    "title"    : "Task 1 - Google CTF Beginners Quest 2021",
    "category" : "coding, CTF, google",
    "url"      : "/coding/ctf/google/2022/02/28/google-beginner-ctf-2021/",
    "date"     : "February 28, 2022",
    "excerpt"  : "CTF (Catch the Flag) in the programming world is a competition where you hack/solve puzzles in order to get a code to get the next puzzle. You might to use several tricks and a plenty of imagination to get something like this: CTF{This_is_how_flag...",
    "content"  : "CTF (Catch the Flag) in the programming world is a competition where you hack/solve puzzles in order to get a code to get the next puzzle. You might to use several tricks and a plenty of imagination to get something like this: CTF{This_is_how_flags_usually_look_like}.\n\nA really nice introduction to what CTF competition is  LiveOverflow YouTube Channel with their pros and cons. I took the Google CTF Beginners Quest 2021,  I have learned some interesting stuff so I wanted to make a post detailing some of them.\n\nYou can go and check this CFT at https://capturetheflag.withgoogle.com/beginners-quest.\n\nTask 1:\n\nGet the password for this website https://cctv-web.2021.ctfcompetition.com/, this is what it looks like.\n\n\n\nCheck the inspect the html code using your favorite web browser. You get the following code:\n\nconst checkPassword = () =&amp;gt; {\n  const v = document.getElementById(&quot;password&quot;).value;\n  const p = Array.from(v).map(a =&amp;gt; 0xCafe + a.charCodeAt(0));\n\n  if(p[0] === 52037 &amp;amp;&amp;amp;\n     p[6] === 52081 &amp;amp;&amp;amp;\n     p[5] === 52063 &amp;amp;&amp;amp;\n     p[1] === 52077 &amp;amp;&amp;amp;\n     p[9] === 52077 &amp;amp;&amp;amp;\n     p[10] === 52080 &amp;amp;&amp;amp;\n     p[4] === 52046 &amp;amp;&amp;amp;\n     p[3] === 52066 &amp;amp;&amp;amp;\n     p[8] === 52085 &amp;amp;&amp;amp;\n     p[7] === 52081 &amp;amp;&amp;amp;\n     p[2] === 52077 &amp;amp;&amp;amp;\n     p[11] === 52066) {\n    window.location.replace(v + &quot;.html&quot;);\n  } else {\n    alert(&quot;Wrong password!&quot;);\n  }\n}\n\n\nWe enter the code and the program stores it inside the const v, then the code transforms the characters into integer values after adding 0xCafe. To obtain the password, we need to check what values are stored in the p[i]: Python is our friend.\n\nimport numpy as np\n\n# Checking the code, we need at least 12 values\n\np = np.zeros(12)\n\np[0] = 52037\np[6] = 52081\np[5] = 52063\np[1] = 52077\np[9] = 52077\np[10]= 52080\np[4] = 52046\np[3] = 52066\np[8] = 52085\np[7] = 52081\np[2] = 52077 \np[11]= 52066 #12 values\n\n#Convert 0xCafe to integer value\n#16 is the ASCII base, represented by &#39;0x&#39;\noffset = int(&#39;0xCafe&#39;,16) \n\np -=  offset # Deletes the offset \n\nfor i in p: \n     # Print the password\n     print(chr(int(i)), end=&quot;&quot;)\n\n\n\nAnd the password is GoodPassword, it takes you to a new page with the flag at the bottom.\n\n\n"
} ,
  
  {
    "title"    : "Ayuda para el Ingreso IB",
    "category" : "spanish",
    "url"      : "/ingreso.html",
    "date"     : "February 1, 2022",
    "excerpt"  : "Editado por última vez: 14 de Enero, 2022\n\n\n  Querido intentante (como los alumnos de IB le dicen a los que planean rendir el examen de ingreso), bienvenido a esta locura. Podes encontrar cosas útiles y no tan útiles para ayudarte a ser un ingresa...",
    "content"  : "Editado por última vez: 14 de Enero, 2022\n\n\n  Querido intentante (como los alumnos de IB le dicen a los que planean rendir el examen de ingreso), bienvenido a esta locura. Podes encontrar cosas útiles y no tan útiles para ayudarte a ser un ingresante del IB.\nLas ayudas son más para estudiantes de grado, pero posgrado y doctorado pueden pasar a mirar.\n\n\nLinks Oficiales:\n\n\n  \n    Página del Instituto Balseiro: Ahí están los formularios, los deadlines, etc. Empezá por ahí.!\n  \n  \n    El Oráculo: Casi todos los exámenes de ingreso anteriores están ahí. Podés preguntar cosas ahí y te va a responder de forma “oficial”.\n  \n\n\nLinks no oficiales:\n\nEstas son cosas manejadas por ex-alumnos, no esperes seriedad pero si vas a buscar ayuda la vas a encontrar\n\nPara hablar con alumnos/egresados/otros intentantes\n\n\n  Server de Discord\n  Telegram\n  WhatsApp\n\n\nCarpetas con exámenes, ayudas, propuestas de solución, etc.\nToma las propuestas de solución con pinzas, cualquier duda podés preguntar al oráculo:\n\n\n  Examenes: Libros, examenes, soluciones y más\n  Examenes+: lista de muchos examenes + extra\n  Examenes++: lista de muchos examenes\n  Examenes+++: Soluciones de un alumno separados por tema\n\n\nAyudas para antes y después del examen\n\nEstas guías están abiertas a comentarios, son cosas que nosotros (alumnos y egresados involucrados en los grupos) pensamos que son  relevantes:\n\n\n  Ayuda para el examen según algunos alumnos/egresados\n  Ayuda para la entrevista\n  ¿Cómo es vivir en el IB-CAB?: si para la desgracia de tu vida social, ingresaste.\n\n"
} ,
  
  {
    "title"    : "Github Repos of NN and DNN classes/code",
    "category" : "",
    "url"      : "/gitgraduate.html",
    "date"     : "January 1, 2022",
    "excerpt"  : "Different repos for the people, I hope you find them useful\n\nNN Clases/Code\n\nBasic Neural Network introduction exercises  in this link.\n\nDNN Clases/Code\n\nSolutions to tutorial classes and more in this link.\n\nResources for HU ML für Physiker classe...",
    "content"  : "Different repos for the people, I hope you find them useful\n\nNN Clases/Code\n\nBasic Neural Network introduction exercises  in this link.\n\nDNN Clases/Code\n\nSolutions to tutorial classes and more in this link.\n\nResources for HU ML für Physiker classes - Winter Term 2021/2022\n\nDatasets use for Exercises 4 to 6,  here\n"
} 
  
]
